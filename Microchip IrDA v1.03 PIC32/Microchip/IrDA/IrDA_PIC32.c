/*

Microchip IrDA Standard Stack

PIC32MX Driver file

This file provides the low level driver functions for the Microchip IrDA
Standard Stack.  It provides the various clock functions (utilizing Timer 2)
and performs the lowest level character reception and transmission (utilizing
the selected UART).

To utilize the stack, link the following files:

1. Application files
2. myIrDA.c (generated by the Microchip IrDA Stack Tool (MIST.EXE)
3. Target device driver file (this or other device specific file)
4. IrDA Standard protocol library (as indicated by MIST.EXE)


TIMING CONSIDERATIONS

The IrDA Standard Stack using UART receive and transmit interrupts.  Review
the application note and README file for important timing information
concerning Fosc selection and baud rate support.  The stack configuration
tool MIST.EXE can help select an Fosc value to support the desired baud
rate(s).  To determine the amount of interrupt processing required, MIST.EXE
requires the number of instructions executed during the interrupt handler.
This version of the driver requires approximately 300 instructions.


IMPORTANT NOTES

Review the device errata for any modifications that may be required for a
particular target device.

The PIC24 currently does not have a method to disable the RX while TX is in
progress.  Therefore, we make get crosstalk. To eliminate errors, we disable the
receive interrupt when we would turn off the receiver, and clear the interrupt
flag, flush any received bytes, and re-enable the receive interrupt when we
would turn it on.

Do not define POLLING_MODE_RX or POLLING_MODE_TX.  Only interrupt mode
is supported.  To support polling, the libraries must be rebuilt.  These
sections are included in the stack for potential future enhancements.

Author                Date      Comment
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
KO                 11-Oct-2006  v1.0
KO                 21-Jun-2007  v1.01
KO                 31-Oct-2008  v1.02
********************************************************************************

Software License Agreement

Copyright © 2007 Microchip Technology Inc. and its licensors.
All rights reserved.

Microchip licenses to you the right to: (1) install Software on a single
computer and use the Software with Microchip 16-bit microcontrollers and 16-bit
digital signal controllers (“Microchip Product”); and (2) at your own
discretion and risk, use, modify, copy and distribute the device driver files
of the Software that are provided to you in Source Code; provided that such
Device Drivers are only used with Microchip Products and that no open source or
free software is incorporated into the Device Drivers without Microchip’s prior
written consent in each instance.

You should refer to the license agreement accompanying this Software for
additional information regarding your rights and obligations.

SOFTWARE AND DOCUMENTATION ARE PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND,
EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT OR CONSEQUENTIAL
DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF SUBSTITUTE GOODS,
TECHNOLOGY, SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO
ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.

********************************************************************************
 */

#include <IrDA\IrDA_PIC32.h>
#include "HardwareProfile.h"

//#define TRACE_PIC
//#define APP_TRACE  2
//Note: Polled mode not supported*/

#ifdef TRACE_PIC
    #include "uart.h"
    extern BYTE testFlag;
#endif
#if APP_TRACE >= 1
    #include "uart.h"
#endif
enum
{   
    _REG,
    _CLR,
    _SET,
    _INV
};
typedef volatile unsigned int   *PSFR;

UINT	_UartStaRxTx = 0;

#ifdef POLLING_MODE_RX
    #define RX_OFF()	    UxSTAbits.URXEN = 0;
    #define RX_ON()     	UxSTAbits.URXEN = 1;

#else

inline  void RX_OFF(void)
{  
	PSFR    sta;

    sta = (PSFR)&UxSTA;

    // make sure that we are not receiving
    // check the Rx Buffer full, Rx Idle, and Rx int flag
    while((sta[_REG] & _UxSTA_URXDA_MASK) || !(sta[_REG] & _UxSTA_RIDLE_MASK));

    sta[_CLR] = _UxSTA_URXEN_MASK;
	
    RxIntEnable(0);
    RxClearIntFlag();
    
    _UartStaRxTx &= ~_UxSTA_URXEN_MASK;
    
}
inline void RX_ON(void)
{	
	PSFR    sta;

    sta = (PSFR)&UxSTA;

    if(!(sta[_REG] & _UxSTA_URXEN_MASK))
    {
        RxIntEnable(0);

	    sta[_SET] = _UxSTA_URXEN_MASK;

        while (sta[_REG] & _UxSTA_URXDA_MASK)
        {                      
            UINT temp;
        
            temp = UxRXREG;    
        }                      	

	    RxClearIntFlag();
    }	    
    RxIntEnable(1);
    _UartStaRxTx |= _UxSTA_URXEN_MASK;
}

inline void UartOn(void)
{
	UINT    rx_int, tx_int;
	PSFR    sta;

    sta = (PSFR)&UxSTA;
	
	UxMODEbits.IREN = 1;	
	sta[_SET] = _UartStaRxTx;
	sta[_CLR] = _UxSTA_OERR_MASK;

    rx_int = RxGetIntEnable();
    RxIntEnable(0);

    tx_int = TxGetIntEnable();
    TxIntEnable(0);

    UxMODEbits.UARTEN = 1;
	
    if(_UartStaRxTx & _UxSTA_URXEN_MASK)
	{
        while (sta[_REG] & _UxSTA_URXDA_MASK)
        {                      
            UINT temp;
        
            temp = UxRXREG;    
        }                      
	
	    RxClearIntFlag();
	}	

   
   RxIntEnable(rx_int);
    TxIntEnable(tx_int);
	    
}
inline void UartOff(void)
{
	_UartStaRxTx = UxSTA & (_UxSTA_UTXEN_MASK | _UxSTA_URXEN_MASK);
	UxMODEbits.UARTEN = 0;
		
}			
#endif


#ifdef POLLING_MODE_TX
    BYTE    UARTxPutChar( char Ch );
#endif
#ifdef POLLING_MODE_RX
    char    UARTxCharReady();
    char    UARTxGetChar();
#endif
void     UARTxSetBaud( DWORD baud );

//******************************************************************************
//******************************************************************************
//    UART Functions
//******************************************************************************
//******************************************************************************

/*******************************************************************************
Function:       void DisableIrDAInterrupts( void )

Precondition:   None

Overview:       This function disables IrDA interrupts by raising the CPU
                priority.  It may be customized if desired.

Input:          None

Output:         None
*******************************************************************************/
// this is prototype UART be careful of presistant interrupts
void DisableIrDAInterrupts( void )
{
    INTDisableInterrupts();
}

/*******************************************************************************
Function:       void DisableIrDAInterrupts( void )

Precondition:   None

Overview:       This function disables IrDA interrupts by raising the CPU
                priority.  It may be customized if desired.

Input:          None

Output:         None
*******************************************************************************/
void EnableIrDAInterrupts( void )
{
    INTEnableInterrupts();
}

#ifndef POLLING_MODE_RX
    /*******************************************************************************
    ISR:            void __attribute__((__interrupt__, auto_psv)) _U1RXInterrupt(void)

    Precondition:   UART has been initialized.

    Overview:       This ISR is called when the receive interrupt occurs.  While the
                    receive FIFO has bytes in it, the bytes are read and sent to
                    the receive framer.  If a receive queue is being used, they are
                    enqueued rather than being sent to the framer.

    Input:          None

    Output:         None
    *******************************************************************************/
    void _IrDAHandler(void)
    {
        BYTE    clearToTurnOff;
        SHORT   next_char; // NOTE - must be signed
        BYTE tempChar;
        static BYTE tx_pass = 0;
        static count =0;
            if (RxGetIntFlag() )
            {
                   #ifdef TRACE_PIC
                   UARTxPutChar('r');
                   #endif

                while (UxSTAbits.URXDA && count++> 0)
                {
                    
                   #ifndef RX_CHAR_BUF
                        #ifdef TRACE_PIC
                            tempChar = UxRXREG;
                            UARTxPutChar( '<' );
                            UARTxPutHex( tempChar );
                            UARTxPutChar( '>' );
                            RX_Framer( tempChar );
                        #else
                            tempChar = UxRXREG;
                            RX_Framer( tempChar );
                        #endif
                    #else
                        #ifdef TRACE_PIC
                            tempChar = UxRXREG;
                            UARTxPutChar( tempChar );
                            rx_chars[rx_chars_head ++] = tempChar;
                        #else
                            rx_chars[rx_chars_head ++] = UxRXREG;
                        #endif
                        if(rx_chars_head > MAX_RX_CHARS - 1)
                            rx_chars_head = 0;

                    #endif
  
             }

               RxClearIntFlag();
           }
            if (TxGetIntFlag())
            {
                   #ifdef TRACE_PIC
                   UARTxPutChar('t');
                   #endif  

                clearToTurnOff = TRUE;
    
                if((next_char = TX_Framer()) >  - 1)
                {
                    clearToTurnOff = FALSE;
                    UxTXREG = next_char;
                    #ifdef TRACE_PIC
                        UARTxPutChar('<');
                        UARTxPutHex(next_char);
                        UARTxPutChar('>');
                    #endif
                }
                else if (clearToTurnOff)
                {
                    PSFR    sta;

                    sta = (PSFR)&UxSTA;

                    #ifdef TRACE_PIC
                        UARTxPutChar('d');
                    #endif
                    while (!UxSTAbits.TRMT);    // Wait here, just in case the transmitter isn't really done.
                    sta[_CLR] = _UxSTA_UTXEN_MASK;
                    TxIntEnable(0);            // Disable the transmit interrupt
                    RX_ON();                    // Flush all received characters
                }
            TxClearIntFlag();
            }
            
    }
#endif


#ifdef POLLING_MODE_RX
    /*******************************************************************************
    Function:       void Do_RX_Poll( void )

    Precondition:   UART has been initialized

    Overview:       This function polls the UART to see if a character has been
                    received.  It is compiled in only if we are polling.

    Input:          None

    Output:         None
    *******************************************************************************/
    void Do_RX_Poll( void )
    {
        BYTE    flag;
        BYTE    inchar;

        if(UARTxCharReady())
        {
            while(1)
            {
                // Get the input character and pass it to the framer.
                inchar = UARTxGetChar();
                RX_Framer(inchar);

                // If we received the end of frame char, break out of the loop.
                if(inchar == 0xc1)
                    break;

                // Wait for the next character.
                WAITTIMEOUT_ND( UARTxCharReady(), 100, flag );
                #if ERR_TRACE >= 1
                    if( flag )
                    {
                        //  If we timed out, break out of the loop.
                        xprintf("!!Do_RX_Poll:RX TIMEOUT\n");
                        break;
                    }
                #endif
            }
        }
    }
#endif


/*******************************************************************************
Function:       BYTE Com_ioctl(BYTE param,DWORD value)

Precondition:   UART has been initialized and is running.

Overview:       Performs some UART control based on the input parameters.

Input:          param - what function to perform
                    IOCTL_RX_EN Enables the receiver
                    IOCTL_BAUD  Sets the baud rate to the specified value
                value - dependent on param

Output:         0 - success
                1 - unknown value
                2 - unknown param
*******************************************************************************/
BYTE Com_ioctl( BYTE param, DWORD value )
{

    if(param == IOCTL_RX_EN)
    {
        RX_ON();
        return (0);
    }
    if(param == IOCTL_BAUD)
    {
        #if   defined(BAUDRATE_115200)
            if((value == 9600l) || (value == 19200l) || (value == 38400l) || (value == 57600l) || (value == 115200l))
        #elif defined(BAUDRATE_57600)
            if((value == 9600l) || (value == 19200l) || (value == 38400l) || (value == 57600l))
        #elif defined(BAUDRATE_38400)
            if((value == 9600l) || (value == 19200l) || (value == 38400l))
        #elif defined(BAUDRATE_19200)
            if((value == 9600l) || (value == 19200l))
        #else
            if((value == 9600l))
        #endif
        {
            #if APP_TRACE >= 1
                DBPRINTF( "****Com_ioctl: Change baud to %8ld\n", value );
            #endif

            SYS_DELAY_ND(50);

	        UartOff();
	        UARTxSetBaud(value);            // Set baud rate
            UartOn();						// Enable the UART
			
            return (0);
        }
        return (1); /* unknown value */
    }
    return (2); /* unknown param */
}


/*******************************************************************************
Function:       void Com_terminate( void )

Precondition:   None

Overview:       Turns of the UART, and disables interrupts if they are used.

Input:          None

Output:         None
*******************************************************************************/
void Com_terminate( void )
{
    UartOff();

    #ifndef POLLING_MODE_RX
            RxIntEnable(0);
    #endif
    #ifndef POLLING_MODE_TX
        TxIntEnable(0);
    #endif
}

/*******************************************************************************
Function:       void Com_init( DWORD baud )

Precondition:   None

Overview:       Turns on and initializes the UART to the specified baud rate.
                If interrupts are used, they are enabled.

Input:          Desired baud rate

Output:         None

Notes:          Let the UART peripheral set the directions of UART IOs.
*******************************************************************************/
void Com_init( DWORD baud )
{
    UxMODE = 0;                     // 8 bits, no parity, 1 stop bit
    UxMODEbits.IREN = 1;            // Enable IrDA mode
    UARTxSetBaud( baud );
    UxSTA = 0;

    #ifndef POLLING_MODE_RX
        // Set receive interrupt mode to interrupt when a character is in the receive buffer (so we don't miss any)
        UxSTAbits.URXISEL1 = 0;
        UxSTAbits.URXISEL0 = 0;

        // Reset the interrupt flags.
        //***RxIntFlag = 0;

        // Establish priorities and enable interrupts
        //***RxIntPriorityReg = RxIntPriorityVal;
        //***RxIntEnable = 1;
    #endif

    #ifndef POLLING_MODE_TX
        // Set transmit interrupt mode to interrupt when transmit operation over (01)
        // NOTE - This has to be repeated when we turn on the transmitter
        UxSTAbits.UTXISEL1 = 0;
        UxSTAbits.UTXISEL0 = 1;

        // Reset the interrupt flags.
        TxClearIntFlag();

        // Establish priorities and enable interrupts
        TxIntPriorityReg = TxIntPriorityVal;
        TxIntEnable(0);    // Disable until we have something to send
    #endif

    UxMODEbits.UARTEN = 1;          // Enable UART
   	RX_ON(); 	
   	
    
}

/*******************************************************************************
Function:       void Com_write( FBUF *frame )

Precondition:   None

Overview:       Queues the frame and starts the com device to transmit the
                frame.  The com device driver will use the framer functions to
                retrieve the frame from the queue and transmit it.

Input:          Pointer to a allocated frame.

Output:         None
*******************************************************************************/

void Com_write( FBUF *frame )
{
    #if FTYPE_TRACE >= 1
        WORD    tfsize;
    #endif
    #ifdef POLLING_MODE_TX
        SHORT   value;
    #endif
    #if FRAME_TRACE >= 1
        SHORT   i;
        BYTE    *tmpptr;
    #endif

    #if NOSENDFRAME >=1
        return ;
    #endif

    #ifdef INDUCE_STRESS
        tx_cnt ++;
    #endif

    #if FRAME_TRACE >= 1
        tmpptr = (BYTE*)frame+FBUF_HEAD;
        if(tmpptr[1] != XID_RESPONSE)
        {
            for(i = 0;((i < MAX_FRAME_TRACE) && (i < frame -> size - 2));i ++)
                xprintf("[%2x]",tmpptr[i]);
            xprintf("\n");
        }
    #endif

    if( ! (QUEUE_FULL(lap_out_q,MAX_OUT_FRAMES)))
    {
        #ifdef DRIVER_TRACE
            xprintf("DR t1\n");
        #endif

        frame -> type = LOQ_TYPE | (frame -> type &0x80);

        DISABLE_INTS();
        QUEUE_ADD(lap_out_q,frame,MAX_OUT_FRAMES);
        ENABLE_INTS();
    }
    else
    {
        #ifdef DRIVER_TRACE
            xprintf("DR t2\n");
        #endif

        #if ERR_TRACE >= 1
            xprintf("!!lap_out_q QUEUE_FULL\n");
        #endif
    }

    #ifdef DRIVER_TRACE
        xprintf("****Send frame: pointer:%8ld, lap_out_q.head:%d\n,",(DWORD)tmpptr,lap_out_q.head);
    #endif

    RX_OFF();

    #ifndef POLLING_MODE_TX
        // Enable transmit interrupts so we can transmit the character.  Note that we have to do things
        // here in order.  First, while the interrupt is disabled, turn on the transmitter.  This will trigger
        // the interrupt, but we won't respond yet.  Next, set the transmit interrupt mode.  The device currently
        // requires the transmitter to be on to set the transmit interrupt mode.  Then we can enable the
        // interrupt, which will result in us vectoring immediately to the interrupt handler.  The interrupt mode
        // doesn't matter for the first interrupt - we want that first interrupt to go off as soon as we enable
        // the transmitter.

        UxSTAbits.UTXEN = 1;
        UxSTAbits.UTXISEL1 = 0;
        UxSTAbits.UTXISEL0 = 1;
        TxIntEnable(1);

        // Don't turn the Rx back on here - wait until the transmission is complete.
    #else
        // Send all the framed data as fast as possible.
        while(1)
        {
            if((value = TX_Framer()) >  - 1)
            {
                if(UARTxPutChar(value))
                {
                    #if ERR_TRACE >= 1
                        xprintf("!!UARTxPutChar TO\n");
                    #endif
                    break;
                }
            }
            else
            {
                break;
            }
        }
        // Turn RX back on (or flush the receive buffers)
        RX_ON();
    #endif
}


/*******************************************************************************
Function:       void UARTxSetBaud( DWORD baud )

Precondition:   UART has been disabled, and will be re-enabled later.

Overview:       Sets the baud rate to a specified value

Input:          Desired baud rate.  If an unsupported baud rate is requested,
                the baud rate will be unchanged.

Output:         None
*******************************************************************************/
void UARTxSetBaud( DWORD baud )
{
    #ifdef TRACE_PIC
        UARTxPutChar('(');
        UARTxPutChar( (baud >> 8) & 0xFF );
        UARTxPutChar( (baud & 0xFF) );
        UARTxPutChar(')');
    #endif

    // Wait for the receiver to become idle
    while (!UxSTAbits.RIDLE);


    switch(baud)
    {
        #ifdef BAUDRATE_115200
        case 115200l:
            UxMODEbits.BRGH = BRGH_115200;
            UxBRG = BAUDRATE_115200;
            break;
        #endif
        #ifdef BAUDRATE_57600
        case 57600l:
            UxMODEbits.BRGH = BRGH_57600;
            UxBRG = BAUDRATE_57600;
            break;
        #endif
        #ifdef BAUDRATE_38400
        case 38400l:
            UxMODEbits.BRGH = BRGH_38400;
            UxBRG = BAUDRATE_38400;
            break;
        #endif
        #ifdef BAUDRATE_19200
        case 19200l:
            UxMODEbits.BRGH = BRGH_19200;
            UxBRG = BAUDRATE_19200;
            break;
        #endif
        case 9600:
            UxMODEbits.BRGH = BRGH_9600;
            UxBRG = BAUDRATE_9600;
            break;
    }
}

/*******************************************************************************
Function:        UARTxPutChar

Precondition:    UARTxInit must be called before.

Overview:        Send a byte using the UART.  If the transmit buffer isn't
                 available in 10ms, time out.

Input:           Byte to be sent.

Output:          0 - byte sent successfully
                 1 - byte not sent
*******************************************************************************/
#ifdef POLLING_MODE_TX
BYTE  UARTxPutChar( char Ch )
{
    WORD    send_time;

    UxSTAbits.UTXEN = 1;
    send_time = TIMEMS();

    // Wait until there is space available in the transmit FIFO.
    // Return if we time out.
    while(UxSTAbits.UTXBF == 1)
    {
        if((TIMEMS() - send_time) > 100)
            return (1);
    }

    // Send the charater
    UxTXREG = Ch;

    #ifdef TRACE_PIC
        PrintChar2( Ch );
    #endif

    return 0;
}
#endif

/*******************************************************************************
Function:       UART1CharReady

Precondition:   UART1Init must be called before.

Overview:       Check if there's a new byte in UART reception buffer.

Input:          None.

Output:         Zero if there's no new data received.
*******************************************************************************/
#ifdef POLLING_MODE_RX
char UARTxCharReady()
{
    if (UxSTAbits.URXDA)    //(RxIntFlag == 1)
        return 1;
    return 0;
}
#endif

/*******************************************************************************
Function:        UARTxGetChar

Precondition:    UARTxInit must be called.

Overview:        Read a byte from the UART.  Wait up to 10ms for the byte.

Input:           None.

Output:          Byte received, or 0 on timeout.
*******************************************************************************/
#ifdef POLLING_MODE_RX
char UARTxGetChar()
{
    WORD    send_time;
    char    temp;

    send_time = TIMEMS();

    while (!UxSTAbits.URXDA) //(RxIntFlag == 0)
    {
        if((TIMEMS() - send_time) > 10)
            return (0);
    }

    temp = UxRXREG;

    #ifdef TRACE_PIC
        UARTxPutChar('r');
        UARTxPutHex( temp );
    #endif

    RxIntFlag = 0;
    return temp;
}
#endif

//******************************************************************************
//******************************************************************************
//    Clock Functions
//******************************************************************************
//******************************************************************************

// We are taking Timer 2 for the stack clock.  We will set up the clock period
// such that we get a roll-over at a nice millisecond interval.  The required
// prescaler and period values for a given oscillator frequency and the update
// rate generated are all calculated by MIST.

// NOTE - The datasheet doesn't state this, but the timer does get reset to 0
// after a period register match.  So we don't have to worry about resetting
// the timer manually.

#define STOP_TIMER_IN_IDLE_MODE     0x2000
#define TIMER_SOURCE_INTERNAL       0x0000
#define TIMER_ON                    0x8000
#define GATED_TIME_DISABLED         0x0000
#define TIMER_16BIT_MODE            0x0000
#define TIMER_PRESCALER_1           T2_PS_1_1
#define TIMER_PRESCALER_2           T2_PS_1_2
#define TIMER_PRESCALER_4           T2_PS_1_4
#define TIMER_PRESCALER_8           T2_PS_1_8
#define TIMER_PRESCALER_16          T2_PS_1_16
#define TIMER_PRESCALER_32          T2_PS_1_32
#define TIMER_PRESCALER_64          T2_PS_1_64
#define TIMER_PRESCALER_256         T2_PS_1_256
#define TIMER_INTERRUPT_PRIORITY    0x1000

//#define OLD_CLOCK_METHOD

#ifdef OLD_CLOCK_METHOD
    #define CLOCKHZ     (1000/MILLISECONDS_PER_TICK)
    WORD                clocks_per_sec;
    static WORD         coef;
#endif

volatile WORD D_AREA  newtime;

/*******************************************************************************
Function:       WORD TimeMS(void)

Precondition:   Xclkinit() has been called and the timer is running.

Overview:       Returns the time in milliseconds, based on the number of clock
                ticks that have occurred and how many milliseconds is represented
                by each tick (as set up in MIST).

Input:          None

Output:         Time in milliseconds as an unsigned 16-bit value.

Notes:          This function has been streamlined from the original implementation
                to avoid additional runtime calculations.
*******************************************************************************/

WORD TimeMS( void )
{
    #ifdef OLD_CLOCK_METHOD
        return (Xclock() * coef);
    #else
        return (Xclock() * MILLISECONDS_PER_TICK);
    #endif
}

/*******************************************************************************
Function:        void Xclkinit( void )

Precondition:    None

Overview:        Initializes the stack clock

Input:           None

Output:          None
*******************************************************************************/
void Xclkinit( void )
{
    #ifdef OLD_CLOCK_METHOD
        clocks_per_sec = CLOCKHZ;
    #endif
    newtime = 1;

    OpenTimer2(T2_ON | TIMER_PRESCALER, TIMER_PERIOD); 
    ConfigIntTimer2(T2_INT_ON | T2_INT_PRIOR_2);

    return;
}

/*******************************************************************************
Function:        void Xclkterm( void )

Precondition:    None

Overview:        Stops the stack clock

Input:           None

Output:          None
*******************************************************************************/
void Xclkterm( void )
{
    IEC0bits.T2IE = 0;
    T2CONbits.TON = 0;
}

/*******************************************************************************
Function:       WORD Xclock( void )

Precondition:   None

Overview:       Reads the stack clock.  The returned value must be scaled
                appropriately.

Input:          None

Output:         Time value
*******************************************************************************/
WORD Xclock( void )
{
    return (newtime);
}

/*******************************************************************************
Function:       BYTE Xinittime(void)

Precondition:   None

Overview:       Initializes the millisecond timer.

Input:          None

Output:         None

Notes:          This function is retained for backward compatibility with the
                original stack code.  The time calculations have been streamlined.
*******************************************************************************/

BYTE Xinittime( void )
{
    #ifdef OLD_CLOCK_METHOD
        #ifndef LAN_CLOCK
            coef = 1000 / clocks_per_sec;
        #endif
    #endif
    return (0);
}

/*******************************************************************************
Function:       void __attribute__((__interrupt__, auto_psv)) _T2Interrupt(void)

Precondition:   None

Overview:       Timer ISR, used to update the stack clock

Input:          None

Output:         None
*******************************************************************************/
void __ISR(_TIMER_2_VECTOR, ipl2) _T2Interrupt( void )
{
    if (IFS0bits.T2IF)
    {
        IFS0bits.T2IF = 0;
//        _RA7 ^=1;
        newtime++;
    }
}

